<!doctype html>
<!-- Pour lancer serveur python : aller dans anaconda prompt, cd ...le bon dossier, python -m http.server 
	et ensuite aller sur localhost:8000 -->
<html>
  <head>
    <title>Interface visualisation</title>
    <meta charset="utf-8">
  
	<!--<script src="js/three.js"></script>-->
	<!--<script type="module" src="js/three.module.js"></script>-->
	<script src="js/earcut.js"></script>
	<!--<script type="module" src="js/OrbitControls.js"></script>-->
	<!--
		ANCIENNE VERSION DE D3 JS ?
		<script src="https://d3js.org/d3.v3.min.js" charset="utf-8"></script>
	
	-->
	<script src="https://d3js.org/d3.v4.js"></script>
	<script src="js/jquery.js" charset="utf-8"></script>

	<!--
		ci dessous pour double slider jquery ui
	-->
	<link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
	<script src="https://code.jquery.com/jquery-1.12.4.js"></script>
	<script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>

	<!--
		ci dessus pour double slider jquery ui
	-->

	<!-- <script src="js/add_climate_data_functions.js" charset="utf-8"></script> -->
	<!--<script src="js/load_data_functions.js" charset="utf-8"></script> -->
	<!--<script src="js/color_functions.js" charset="utf-8"></script> -->
	<!--<script src="js/buildings_functions.js" charset="utf-8"></script> -->
	<!--<script src="js/2D_vertical_planes_functions.js" charset="utf-8"></script> -->
    
	<link  href="css/main_2.css" rel="stylesheet"/>
	
  </head>
<body>
  	<div id='main'>	
		<span id="open_menu">
			<svg width="24" height="24" fill="none" xmlns="http://www.w3.org/2000/svg" >
			<path d="M4 15h16v-2H4v2zm0 4h16v-2H4v2zm0-8h16V9H4v2zm0-6v2h16V5H4z" fill="#fff"></path></svg>
		</span>
		<div id="container"></div>
		<div id="menu_container">
			<div id="hide_menu">&times;</div>
			<div id="general_control_container">
				<div id="choose_data_label" class="general_control_container_div" >Choose data </div>
				<div id="choose_data_container">
					<!-- On accède aux valeurs de ces input avec .value
					N'acceptent actuellement que des .csv -->
					<div class="choice_container">
						<label for="data_o">Choose a data _O :</label>
						<input type="file" id="data_o" accept=".csv">
					</div>
					<div class="choice_container">
						<label for="data_u">Choose a data _U :</label>
						<input type="file" id="data_u" accept=".csv">
					</div>
					<div class="choice_container">
						<label for="data_v">Choose a data _V :</label>
						<input type="file" id="data_v" accept=".csv">
					</div>
					<div class="choice_container">
						<label for="data_road">Choose a road data :</label>
						<input type="file" id="data_road" accept=".geojson">
					</div>
					<div id="load_data_container">
						<button id ="load_data"> Load data </button>
					</div>
					<div id ="data_loaded"></div>
				</div>
				<div id="data_control_label" class="general_control_container_div">Data</div>
				<div id="data_control_container">
					<div class="data_control_container_inside">
						
						<div  id="point_control_container_sub" class="control_container_sub">
							<div id="SBL_values" class="values_header">SBL</div>
							<div id="Meso_values" class="values_header">Meso_NH</div>
						</div>
						<div id="values_selection_sbl"></div>
						<div id="values_selection_meso"></div>
						<div id="data_block"></div>
					</div>
				</div>	
				<div id="graphic_control_label" class="general_control_container_div">Graphic</div>
				<div id="graphic_control_container">
					<div id="container_nuage_points">Type de points :</div>
					<div id="h_control">
						<div id="h_control_label">h_factor : 1</div>
						<div id="h_control_slider">
							<div class="slider" id="h_slider"></div>
						</div>
					</div>
					<div id="temp_control">
						diff_temp
						<div id="temp_control_input">
							<input type="text" id="temp_min_input" name="name" value="20">
							<input type="text" id="temp_max_input" name="name" value="30">
						</div>
					</div>
					<div id="color_control">
						<div id="color_control_input" value ="">
						</div>
					</div>
					<div id="color_class_control">
						<select id="color_class_control_input">
							<option value="effectifs_egaux" >Effectifs égaux</option>
							<option value="ecarts_egaux" selected>Intervalles égaux</option>
						</select>
						<!--Liste déroulante du nbe de tableaux faite dynamiquement-->
					</div>
					<div id="temp_histogram_content">
					</div>
					<div id="size_control" class='mono_slider_container'>
						<div id="size_control_label">Size: </div>
						<input type="text" id="size_text_input" class ="mono_slider_input" name="name"/>
						<div class="slider mono_slider" id="size_slider"></div>
						
					</div>
					<div id="relative_size_control">
						<div id="relative_size_factor_control_label">relative_size_factor: 0</div>
						<div id="relative_size_control_input">
							
							<div class="slider" id="relative_size_factor_size_slider"></div>
						</div>
					</div>
					<div id="density_control" class='mono_slider_container'>
						<div id="density_control_label">general density: </div>
						<div id="gnl_density">
							<input type="text" id="density_text_input" class ="mono_slider_input" name="name"/>							
							<div class="slider mono_slider" id="density_slider"></div>
						</div>
					</div>
					<div id="relative_density_factor_control">
						<div id="relative_density_factor_control_label">relative_density_factor: 0</div>
						<div id="relative_density_factor_control_input">
							<div class="slider" id="relative_density_factor_slider"></div>
						</div>
					</div>
					<div id="transparency_control">
						<div id="transparency_control_label">transparency_factor: 1</div>
						<div id="transparency_control_input">
							
							<div class="slider" id="transparency_slider"></div>
						</div>
					</div>
					<div id="number_of_points_real_plane">
						<div id="number_of_points_real_plane_label">number_of_points_real_plane: 10</div>
						<div id="number_of_points_real_plane_input">
							<div class="slider" id="number_of_points_real_plane_slider"></div>
						</div>
					</div>
					<div id="type_bati_div">
						<select id="type_bati" name="type_bati" form="type_bati">
						<option value="autre" selected>autre</option>
					<option value="typo_maj">Typologie majoritaire dans l'USR</option>
					<option value="typo_second">Typologie secondaire dans l'USR</option>
					<option value="build_dens">densité surfacique de bâti</option>
					<option value="hydro_dens">densité surfacique de zone en eau</option>
					<option value="veget_dens">densité surfacique de zone de végétation</option>
					<option value="road_dens">densité surfacique de route</option>
					<option value="ba">pourcentage de "Bâtiment d'Activité" dans l'USR</option>
					<option value="bgh">pourcentage de "Bâtiment de Grande Hauteur" dans l'USR</option>
					<option value="icif">pourcentage d' "Immeuble Continu sur Ilôt Fermé" dans l'USR</option>
					<option value="icio">pourcentage d' "Immeuble Continu sur Ilôt Ouvert" dans l'USR</option>
					<option value="id">pourcentage d' "Immeuble Discontinu" dans l'USR</option>
					<option value="local">pourcentage de "Local" dans l'USR</option>
					<option value="pcif">pourcentage de "Pavillon Continu sur Ilôt Fermé" dans l'USR</option>
					<option value="pcio">pourcentage de "Pavillon Continu sur Ilôt Ouvert" dans l'USR</option>
					<option value="pd">pourcentage de "Pavillon Discontinu" dans l'USR</option>
					<option value="psc">pourcentage de "Pavillon Semi-Discontinu" dans l'USR</option>
					</select>
					</div>
				</div>
				<div id="animation_control_label" class="general_control_container_div">Animation</div>
				<div id="animation_control_container">
					<div id="animation_control">
						<div><input type="checkbox" class="animation_ckbx_class" id="animation_ckbx">Animation</div>
					</div>
					<div id="animation_type">
					<input type="radio" id="animation_type_temp"
					name="temp" value="temp" class="animation_type_checkbox" checked>
					<label for="animation_type_temp">temp</label>

					<input type="radio" id="animation_type_z"
					name="z" value="z" class="animation_type_checkbox">
					<label for="animation_type_z">z</label>

					<input type="radio" id="animation_type_x"
					name="x" value="x" class="animation_type_checkbox">
					<label for="animation_type_x">x</label>
					
					<input type="radio" id="animation_type_y"
					name="y" value="y" class="animation_type_checkbox">
					<label for="animation_type_y">y</label>
					</div>
					<div id="animation_speed_control_label">animation_speed_factor: 0.01</div>
					<div id="animation_speed_control_input">
						<div class="slider" id="animation_speed_slider"></div>
					</div>
				</div>
				<div id="filter_control_label" class="general_control_container_div">Filters</div>
				<div id="filter_control_container">
					<div id="temp-double-slider">
						<p>
							<label for="temperatures">Temperatures :</label>
							<input type="text" id="temperatures-label" readonly style="border:0; color:#361bd3; font-weight:bold;">
						</p>
						
						<div id="temp-slider-range"></div>

					</div>
					<div id="z-double-slider">
						<p>
							<label for="z-slider">Z control :</label>
							<input type="text" id="z-slider-label" readonly style="border:0; color:#361bd3; font-weight:bold;">
						</p>
						
						<div id="z-slider-range"></div>

					</div>
					<div id="h-double-slider">
						<p>
							<label for="h-slider">H control :</label>
							<input type="text" id="h-slider-label" readonly style="border:0; color:#361bd3; font-weight:bold;">
						</p>
						
						<div id="h-slider-range"></div>

					</div>
					<div id="x-double-slider">
						<p>
							<label for="x-slider">X control :</label>
							<input type="text" id="x-slider-label" readonly style="border:0; color:#361bd3; font-weight:bold;">
						</p>
						
						<div id="x-slider-range"></div>

					</div>
					<div id="y-double-slider">
						<p>
							<label for="y-slider">Y control :</label>
							<input type="text" id="y-slider-label" readonly style="border:0; color:#361bd3; font-weight:bold;">
						</p>
						
						<div id="y-slider-range"></div>

					</div>


				</div>
				<div id="choose_params_label" class="general_control_container_div" > Configuration </div>
				<div id="choose_params_container">
					<div class="sauvegarde_params">
						<input type="text" id="button_file_text" placeholder="Nommez votre sauvegarde"/>
						<input type="button" id="button_file" value="Sauver configuration actuelle"/>
					</div>
					<div class="sauvegarde_params" id="load_params">
						<div>Charger une configuration :</div>
						<input type="file" id="button_load_file" accept=".txt" />
					</div>
				</div>
			</div>
			
		</div>
	</div>
	
	<!-- Div liste couleur position absolute-->
	<div id='color_list_absolute'></div>
	
	
	
  <script type="x-shader/x-vertex" id="vertexshader_fix_3D_points">
		precision highp float;
		precision mediump sampler3D;
		uniform float x_factor_min;
		uniform float x_factor_max;
		uniform float y_factor_min;
		uniform float y_factor_max;
		uniform float z_factor_min;
		uniform float z_factor_max;
		uniform float h_factor_min;
		uniform float h_factor_max;
		uniform float temp_factor_min;
		uniform float temp_factor_max;
		uniform float regularSize;
		uniform float relativeSizeFactor;
		uniform vec3 u_size;
		uniform vec2 u_clim;
		uniform sampler2D zs_data;
		uniform sampler3D u_data;
		uniform float x_min;
		uniform float x_max;
		uniform float y_min;
		uniform float y_max;
		uniform float mesolimit[38];
		uniform float cst_X;
		uniform float cst_Y;
		uniform float cst_Z;
		uniform float zs;

		attribute float x_position;
		attribute float y_position;
		attribute float z_position;
		attribute float h_position;
		attribute float customtransparency;
		attribute float custompercentage; 
		attribute float voxel_level;
		varying vec3 v_position;
		varying vec3 voxel_position;
		varying float transparency;
		varying float tempPercentage;

		float sample1(vec3 texcoords) {
			/* Sample float value from a 3D texture. Assumes intensity data. */
			return texture(u_data, texcoords.xyz).r;
		}

		void main() {
			v_position = position;

			float voxel_position_x = (v_position[0] - x_min)/(x_max - x_min)*u_size[0];
			float voxel_position_y = -(v_position[2] - y_min)/(y_max - y_min)*u_size[2];
			float voxel_position_z = 0.0;
			vec2 voxel_xy = vec2(voxel_position_x,voxel_position_y);
			float new_zs = texture(zs_data, (voxel_xy/vec2(u_size[0],u_size[2])).xy).r;
			
			if(voxel_level < 7.0){
				if((new_zs+ mesolimit[0])*cst_Z > v_position[1]){
					voxel_position_z = 0.0;
				} else {
					for(int i=1; i< 7; i++){
						if((new_zs + mesolimit[i])*cst_Z > v_position[1]){
							float z_min = new_zs + mesolimit[i-1];
							float z_max = new_zs + mesolimit[i];
							voxel_position_z = (v_position[1] - z_min*cst_Z)/(z_max*cst_Z - z_min*cst_Z) + float(i) - 1.0;
							break;
						}				
					}
				}
			} else {
				if((new_zs+ mesolimit[7])*cst_Z > v_position[1]){
						voxel_position_z = 6.0;
					} else {
						for(int i=8; i< 38; i++){
							if((new_zs + mesolimit[i])*cst_Z > v_position[1]){
								float z_min = new_zs + mesolimit[i-1];
								float z_max = new_zs + mesolimit[i];
								voxel_position_z = (v_position[1] - z_min*cst_Z)/(z_max*cst_Z - z_min*cst_Z) + float(i) - 1.0;
								break;
							}				
						}
					}
			}
						
			voxel_position = vec3(voxel_position_x,voxel_position_y,voxel_position_z); 
	
			float val = sample1(voxel_position/u_size);

			if (val<u_clim[0] || val> u_clim[1]) {
				tempPercentage = -1.0;
			} else {
				tempPercentage = (val - u_clim[0])/(u_clim[1] - u_clim[0]);
				if (tempPercentage < 0.0) {
					tempPercentage = 0.0;
				} else if (tempPercentage > 1.0) {
					tempPercentage = 1.0;
				}
			}

			float sizeShader;
			float addFactor;
			float basicSize = 10000.0;
			if (tempPercentage == 0.5 || relativeSizeFactor == 1.0) {
				sizeShader = basicSize;
			} else if (relativeSizeFactor < 1.0) {
				addFactor = 1.0-relativeSizeFactor;
				sizeShader = (tempPercentage < 0.5) ? basicSize + (basicSize*addFactor*(0.5*tempPercentage)*2.0) : basicSize - (basicSize*addFactor*(0.5*tempPercentage)*2.0) ;
			} else if (relativeSizeFactor > 1.0) {
				addFactor = relativeSizeFactor - 1.0;
				sizeShader = (tempPercentage < 0.5) ? basicSize - (basicSize*addFactor*(0.5*tempPercentage)*2.0) : basicSize + (basicSize*addFactor*(0.5*tempPercentage)*2.0) ;
			}

			vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
			if(custompercentage > temp_factor_min && custompercentage < temp_factor_max && x_position > x_factor_min && x_position < x_factor_max && y_position > y_factor_min && y_position < y_factor_max && z_position > z_factor_min && z_position < z_factor_max && h_position > h_factor_min && h_position < h_factor_max){				
				gl_PointSize = regularSize* sizeShader * ( 1.0 / -mvPosition.z );
			} else {
				gl_PointSize = 0.0;
			}	
			
			transparency = customtransparency;
			gl_Position = projectionMatrix * mvPosition;


			
		}
	</script>
	
	<script type="x-shader/x-fragment" id="fragmentshader_3D_points">
		precision highp float;
		precision mediump sampler3D;

		uniform sampler2D u_cmdata;
		uniform sampler2D pointTexture;
		uniform vec3 u_size;
		
		varying vec3 voxel_position;
				
		varying float transparency;
		varying float tempPercentage;
		

		void main() {
						
			//if(tempPercentage == -1.0){
			//	gl_FragColor = vec4(0.0,0.0,0.0,0.0);
			//
			//} else{
			//	
			//	gl_FragColor = texture2D(u_cmdata, vec2(tempPercentage, 0.5));
			//	gl_FragColor = vec4(gl_FragColor[0],gl_FragColor[1],gl_FragColor[2],transparency);
			//}
						
			float val = fract(float(int(voxel_position[2]))/(u_size[2]/7.0));
			gl_FragColor = texture2D(u_cmdata, vec2(val, 0.5));
									
			vec4 texture4 = texture2D( pointTexture, gl_PointCoord );
			if(texture4.a < 0.8){
				discard;
			}			
			gl_FragColor = gl_FragColor * texture4;
				
		}
	</script>
	
	<script type="x-shader/x-vertex" id="vertexshader_fix_3D_anim_temp">
		precision highp float;
		precision mediump sampler3D;
		uniform float x_factor_min;
		uniform float x_factor_max;
		uniform float y_factor_min;
		uniform float y_factor_max;
		uniform float z_factor_min;
		uniform float z_factor_max;
		uniform float h_factor_min;
		uniform float h_factor_max;
		uniform float temp_factor_min;
		uniform float temp_factor_max;
		uniform float regularSize;
		uniform float relativeSizeFactor;
		uniform vec3 u_size;
		uniform vec2 u_clim;
		uniform sampler2D zs_data;
		uniform sampler3D u_data;
		uniform float x_min;
		uniform float x_max;
		uniform float y_min;
		uniform float y_max;
		uniform float mesolimit[38];
		uniform float cst_X;
		uniform float cst_Y;
		uniform float cst_Z;
		uniform float zs;
		uniform float u_time;
		attribute float x_position;
		attribute float y_position;
		attribute float z_position;
		attribute float h_position;
		attribute float customtransparency;
		attribute float custompercentage; 
		attribute float voxel_level;
		varying vec3 voxel_position;
		varying vec3 v_position;
		varying float transparency;
		varying float tempPercentage;

		float sample1(vec3 texcoords) {
			/* Sample float value from a 3D texture. Assumes intensity data. */
			return texture(u_data, texcoords.xyz).r;
		}

		void main() {
			v_position = position;

			float voxel_position_x = (v_position[0] - x_min)/(x_max - x_min)*u_size[0];
			float voxel_position_y = -(v_position[2] - y_min)/(y_max - y_min)*u_size[2];
			float voxel_position_z = 0.0;
			vec2 voxel_xy = vec2(voxel_position_x,voxel_position_y);
			float new_zs = texture(zs_data, (voxel_xy/vec2(u_size[0],u_size[2])).xy).r;
			if(voxel_level < 7.0){
				if((new_zs+ mesolimit[0])*cst_Z > v_position[1]){
					voxel_position_z = 0.0;
				} else {
					for(int i=1; i< 7; i++){
						if((new_zs + mesolimit[i])*cst_Z > v_position[1]){
							float z_min = new_zs + mesolimit[i-1];
							float z_max = new_zs + mesolimit[i];
							voxel_position_z = (v_position[1] - z_min*cst_Z)/(z_max*cst_Z - z_min*cst_Z) + float(i) - 1.0;
							break;
						}				
					}
				}
			} else {
				if((new_zs+ mesolimit[7])*cst_Z > v_position[1]){
						voxel_position_z = 6.0;
					} else {
						for(int i=8; i< 38; i++){
							if((new_zs + mesolimit[i])*cst_Z > v_position[1]){
								float z_min = new_zs + mesolimit[i-1];
								float z_max = new_zs + mesolimit[i];
								voxel_position_z = (v_position[1] - z_min*cst_Z)/(z_max*cst_Z - z_min*cst_Z) + float(i) - 1.0;
								break;
							}				
						}
					}
			}
			
			voxel_position = vec3(voxel_position_x,voxel_position_y,voxel_position_z); 
	
			float val = sample1(voxel_position/u_size);

			if (val<u_clim[0] || val> u_clim[1]) {
				tempPercentage = -1.0;
			} else {
				tempPercentage = (val - u_clim[0])/(u_clim[1] - u_clim[0]);
				if (tempPercentage < 0.0) {
					tempPercentage = 0.0;
				} else if (tempPercentage > 1.0) {
					tempPercentage = 1.0;
				}
			}

			float sizeShader;
			float addFactor;
			float basicSize = 10000.0;
			if (tempPercentage == 0.5 || relativeSizeFactor == 1.0) {
				sizeShader = basicSize;
			} else if (relativeSizeFactor < 1.0) {
				addFactor = 1.0-relativeSizeFactor;
				sizeShader = (tempPercentage < 0.5) ? basicSize + (basicSize*addFactor*(0.5*tempPercentage)*2.0) : basicSize - (basicSize*addFactor*(0.5*tempPercentage)*2.0) ;
			} else if (relativeSizeFactor > 1.0) {
				addFactor = relativeSizeFactor - 1.0;
				sizeShader = (tempPercentage < 0.5) ? basicSize - (basicSize*addFactor*(0.5*tempPercentage)*2.0) : basicSize + (basicSize*addFactor*(0.5*tempPercentage)*2.0) ;
			}

			vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
			if(custompercentage > temp_factor_min && custompercentage < temp_factor_max && x_position > x_factor_min && x_position < x_factor_max && y_position > y_factor_min && y_position < y_factor_max && z_position > z_factor_min && z_position < z_factor_max && h_position > h_factor_min && h_position < h_factor_max){
					if(abs(sin(u_time + custompercentage)) > 0.9){
						if(abs(sin(u_time + custompercentage)) > 0.95){
							gl_PointSize = regularSize*sizeShader * ( 1.0 / -mvPosition.z );
						} else {
							gl_PointSize = ((abs(sin(u_time + custompercentage)) - 0.9)/(0.95 - 0.9))*abs(sin(u_time + custompercentage))*regularSize*sizeShader * ( 1.0 / -mvPosition.z );
						}
					} else {
						gl_PointSize = 0.0;
					}
				} else {
						gl_PointSize = 0.0;
				}
			
			transparency = customtransparency;
			gl_Position = projectionMatrix * mvPosition;


		}
	</script>
	
	<script type="x-shader/x-vertex" id="vertexshader_fix_3D_anim_z">
		precision highp float;
		precision mediump sampler3D;
		uniform float x_factor_min;
		uniform float x_factor_max;
		uniform float y_factor_min;
		uniform float y_factor_max;
		uniform float z_factor_min;
		uniform float z_factor_max;
		uniform float h_factor_min;
		uniform float h_factor_max;
		uniform float temp_factor_min;
		uniform float temp_factor_max;
		uniform float regularSize;
		uniform float relativeSizeFactor;
		uniform vec3 u_size;
		uniform vec2 u_clim;
		uniform sampler2D zs_data;
		uniform sampler3D u_data;
		uniform float x_min;
		uniform float x_max;
		uniform float y_min;
		uniform float y_max;
		uniform float mesolimit[38];
		uniform float cst_X;
		uniform float cst_Y;
		uniform float cst_Z;
		uniform float zs;
		uniform float u_time;
		attribute float x_position;
		attribute float y_position;
		attribute float z_position;
		attribute float h_position;
		attribute float customtransparency;
		attribute float custompercentage; 
		attribute float voxel_level;
		varying vec3 voxel_position;
		varying vec3 v_position;
		varying float transparency;
		varying float tempPercentage;

		float sample1(vec3 texcoords) {
			/* Sample float value from a 3D texture. Assumes intensity data. */
			return texture(u_data, texcoords.xyz).r;
		}

		void main() {

			v_position = position;
			float voxel_position_x = (v_position[0] - x_min)/(x_max - x_min)*u_size[0];
			float voxel_position_y = -(v_position[2] - y_min)/(y_max - y_min)*u_size[2];
			float voxel_position_z = 0.0;
			vec2 voxel_xy = vec2(voxel_position_x,voxel_position_y);
			float new_zs = texture(zs_data, (voxel_xy/vec2(u_size[0],u_size[2])).xy).r;
			if(voxel_level < 7.0){
				if((new_zs+ mesolimit[0])*cst_Z > v_position[1]){
					voxel_position_z = 0.0;
				} else {
					for(int i=1; i< 7; i++){
						if((new_zs + mesolimit[i])*cst_Z > v_position[1]){
							float z_min = new_zs + mesolimit[i-1];
							float z_max = new_zs + mesolimit[i];
							voxel_position_z = (v_position[1] - z_min*cst_Z)/(z_max*cst_Z - z_min*cst_Z) + float(i) - 1.0;
							break;
						}				
					}
				}
			} else {
				if((new_zs+ mesolimit[7])*cst_Z > v_position[1]){
						voxel_position_z = 6.0;
					} else {
						for(int i=8; i< 38; i++){
							if((new_zs + mesolimit[i])*cst_Z > v_position[1]){
								float z_min = new_zs + mesolimit[i-1];
								float z_max = new_zs + mesolimit[i];
								voxel_position_z = (v_position[1] - z_min*cst_Z)/(z_max*cst_Z - z_min*cst_Z) + float(i) - 1.0;
								break;
							}				
						}
					}
			}
			
			voxel_position = vec3(voxel_position_x,voxel_position_y,voxel_position_z); 
	
			float val = sample1(voxel_position/u_size);

			if (val<u_clim[0] || val> u_clim[1]) {
				tempPercentage = -1.0;
			} else {
				tempPercentage = (val - u_clim[0])/(u_clim[1] - u_clim[0]);
				if (tempPercentage < 0.0) {
					tempPercentage = 0.0;
				} else if (tempPercentage > 1.0) {
					tempPercentage = 1.0;
				}
			}

			float sizeShader;
			float addFactor;
			float basicSize = 10000.0;
			if (tempPercentage == 0.5 || relativeSizeFactor == 1.0) {
				sizeShader = basicSize;
			} else if (relativeSizeFactor < 1.0) {
				addFactor = 1.0-relativeSizeFactor;
				sizeShader = (tempPercentage < 0.5) ? basicSize + (basicSize*addFactor*(0.5*tempPercentage)*2.0) : basicSize - (basicSize*addFactor*(0.5*tempPercentage)*2.0) ;
			} else if (relativeSizeFactor > 1.0) {
				addFactor = relativeSizeFactor - 1.0;
				sizeShader = (tempPercentage < 0.5) ? basicSize - (basicSize*addFactor*(0.5*tempPercentage)*2.0) : basicSize + (basicSize*addFactor*(0.5*tempPercentage)*2.0) ;
			}
			vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
			if(custompercentage > temp_factor_min && custompercentage < temp_factor_max && x_position > x_factor_min && x_position < x_factor_max && y_position > y_factor_min && y_position < y_factor_max && z_position > z_factor_min && z_position < z_factor_max && h_position > h_factor_min && h_position < h_factor_max){
				if(abs(sin(u_time + 3.14159265359*z_position)) > 0.9){
					if(abs(sin(u_time + 3.14159265359*z_position)) > 0.95){
						gl_PointSize = regularSize*sizeShader * ( 1.0 / -mvPosition.z );
					} else {
						gl_PointSize = ((abs(sin(u_time + 3.14159265359*z_position)) - 0.9)/(0.95 - 0.9))*abs(sin(u_time + 3.14159265359*z_position))*regularSize*sizeShader * ( 1.0 / -mvPosition.z );
					}
				} else {
					gl_PointSize = 0.0;
				}
			} else {
				gl_PointSize = 0.0;
			}
			
			transparency = customtransparency;
			gl_Position = projectionMatrix * mvPosition;
		}
	</script>
	
	<script type="x-shader/x-vertex" id="vertexshader_fix_3D_anim_x">
		precision highp float;
		precision mediump sampler3D;
		uniform float x_factor_min;
		uniform float x_factor_max;
		uniform float y_factor_min;
		uniform float y_factor_max;
		uniform float z_factor_min;
		uniform float z_factor_max;
		uniform float h_factor_min;
		uniform float h_factor_max;
		uniform float temp_factor_min;
		uniform float temp_factor_max;
		uniform float regularSize;
		uniform float relativeSizeFactor;
		uniform vec3 u_size;
		uniform vec2 u_clim;
		uniform sampler2D zs_data;
		uniform sampler3D u_data;
		uniform float x_min;
		uniform float x_max;
		uniform float y_min;
		uniform float y_max;
		uniform float mesolimit[38];
		uniform float cst_X;
		uniform float cst_Y;
		uniform float cst_Z;
		uniform float zs;
		uniform float u_time;
		attribute float x_position;
		attribute float y_position;
		attribute float z_position;
		attribute float h_position;
		attribute float customtransparency;
		attribute float custompercentage;
		attribute float voxel_level;		
		varying vec3 voxel_position;
		varying vec3 v_position;
		varying float transparency;
		varying float tempPercentage;

		float sample1(vec3 texcoords) {
			/* Sample float value from a 3D texture. Assumes intensity data. */
			return texture(u_data, texcoords.xyz).r;
		}

		void main() {
			v_position = position;

			float voxel_position_x = (v_position[0] - x_min)/(x_max - x_min)*u_size[0];
			float voxel_position_y = -(v_position[2] - y_min)/(y_max - y_min)*u_size[2];
			float voxel_position_z = 0.0;
			vec2 voxel_xy = vec2(voxel_position_x,voxel_position_y);
			float new_zs = texture(zs_data, (voxel_xy/vec2(u_size[0],u_size[2])).xy).r;
			if(voxel_level < 7.0){
				if((new_zs+ mesolimit[0])*cst_Z > v_position[1]){
					voxel_position_z = 0.0;
				} else {
					for(int i=1; i< 7; i++){
						if((new_zs + mesolimit[i])*cst_Z > v_position[1]){
							float z_min = new_zs + mesolimit[i-1];
							float z_max = new_zs + mesolimit[i];
							voxel_position_z = (v_position[1] - z_min*cst_Z)/(z_max*cst_Z - z_min*cst_Z) + float(i) - 1.0;
							break;
						}				
					}
				}
			} else {
				if((new_zs+ mesolimit[7])*cst_Z > v_position[1]){
						voxel_position_z = 6.0;
					} else {
						for(int i=8; i< 38; i++){
							if((new_zs + mesolimit[i])*cst_Z > v_position[1]){
								float z_min = new_zs + mesolimit[i-1];
								float z_max = new_zs + mesolimit[i];
								voxel_position_z = (v_position[1] - z_min*cst_Z)/(z_max*cst_Z - z_min*cst_Z) + float(i) - 1.0;
								break;
							}				
						}
					}
			}
			
			voxel_position = vec3(voxel_position_x,voxel_position_y,voxel_position_z); 
	
			float val = sample1(voxel_position/u_size);

			if (val<u_clim[0] || val> u_clim[1]) {
				tempPercentage = -1.0;
			} else {
				tempPercentage = (val - u_clim[0])/(u_clim[1] - u_clim[0]);
				if (tempPercentage < 0.0) {
					tempPercentage = 0.0;
				} else if (tempPercentage > 1.0) {
					tempPercentage = 1.0;
				}
			}

			float sizeShader;
			float addFactor;
			float basicSize = 10000.0;
			if (tempPercentage == 0.5 || relativeSizeFactor == 1.0) {
				sizeShader = basicSize;
			} else if (relativeSizeFactor < 1.0) {
				addFactor = 1.0-relativeSizeFactor;
				sizeShader = (tempPercentage < 0.5) ? basicSize + (basicSize*addFactor*(0.5*tempPercentage)*2.0) : basicSize - (basicSize*addFactor*(0.5*tempPercentage)*2.0) ;
			} else if (relativeSizeFactor > 1.0) {
				addFactor = relativeSizeFactor - 1.0;
				sizeShader = (tempPercentage < 0.5) ? basicSize - (basicSize*addFactor*(0.5*tempPercentage)*2.0) : basicSize + (basicSize*addFactor*(0.5*tempPercentage)*2.0) ;
			}

			vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
			if(custompercentage > temp_factor_min && custompercentage < temp_factor_max && x_position > x_factor_min && x_position < x_factor_max && y_position > y_factor_min && y_position < y_factor_max && z_position > z_factor_min && z_position < z_factor_max && h_position > h_factor_min && h_position < h_factor_max){
				if(abs(sin(u_time + 3.14159265359*x_position)) > 0.9){
					if(abs(sin(u_time + 3.14159265359*x_position)) > 0.95){
						gl_PointSize = regularSize*sizeShader * ( 1.0 / -mvPosition.z );
					} else {
						gl_PointSize = ((abs(sin(u_time + 3.14159265359*x_position)) - 0.9)/(0.95 - 0.9))*abs(sin(u_time + 3.14159265359*x_position))*regularSize*sizeShader * ( 1.0 / -mvPosition.z );
					}
				} else {
					gl_PointSize = 0.0;
				}
			} else {
				gl_PointSize = 0.0;
			}
			
			transparency = customtransparency;
			gl_Position = projectionMatrix * mvPosition;
		}
	</script>
	
	<script type="x-shader/x-vertex" id="vertexshader_fix_3D_anim_y">
		precision highp float;
		precision mediump sampler3D;
		uniform float x_factor_min;
		uniform float x_factor_max;
		uniform float y_factor_min;
		uniform float y_factor_max;
		uniform float z_factor_min;
		uniform float z_factor_max;
		uniform float h_factor_min;
		uniform float h_factor_max;
		uniform float temp_factor_min;
		uniform float temp_factor_max;
		uniform float regularSize;
		uniform float relativeSizeFactor;
		uniform vec3 u_size;
		uniform vec2 u_clim;
		uniform sampler2D zs_data;
		uniform sampler3D u_data;
		uniform float x_min;
		uniform float x_max;
		uniform float y_min;
		uniform float y_max;
		uniform float mesolimit[38];
		uniform float cst_X;
		uniform float cst_Y;
		uniform float cst_Z;
		uniform float zs;
		uniform float u_time;
		attribute float x_position;
		attribute float y_position;
		attribute float z_position;
		attribute float h_position;
		attribute float customtransparency;
		attribute float custompercentage; 
		attribute float voxel_level;
		varying vec3 voxel_position;
		varying vec3 v_position;
		varying float transparency;
		varying float tempPercentage;

		float sample1(vec3 texcoords) {
			/* Sample float value from a 3D texture. Assumes intensity data. */
			return texture(u_data, texcoords.xyz).r;
		}

		void main() {
			v_position = position;

			float voxel_position_x = (v_position[0] - x_min)/(x_max - x_min)*u_size[0];
			float voxel_position_y = -(v_position[2] - y_min)/(y_max - y_min)*u_size[2];
			float voxel_position_z = 0.0;
			vec2 voxel_xy = vec2(voxel_position_x,voxel_position_y);
			float new_zs = texture(zs_data, (voxel_xy/vec2(u_size[0],u_size[2])).xy).r;
			if(voxel_level < 7.0){
				if((new_zs+ mesolimit[0])*cst_Z > v_position[1]){
					voxel_position_z = 0.0;
				} else {
					for(int i=1; i< 7; i++){
						if((new_zs + mesolimit[i])*cst_Z > v_position[1]){
							float z_min = new_zs + mesolimit[i-1];
							float z_max = new_zs + mesolimit[i];
							voxel_position_z = (v_position[1] - z_min*cst_Z)/(z_max*cst_Z - z_min*cst_Z) + float(i) - 1.0;
							break;
						}				
					}
				}
			} else {
				if((new_zs+ mesolimit[7])*cst_Z > v_position[1]){
						voxel_position_z = 6.0;
					} else {
						for(int i=8; i< 38; i++){
							if((new_zs + mesolimit[i])*cst_Z > v_position[1]){
								float z_min = new_zs + mesolimit[i-1];
								float z_max = new_zs + mesolimit[i];
								voxel_position_z = (v_position[1] - z_min*cst_Z)/(z_max*cst_Z - z_min*cst_Z) + float(i) - 1.0;
								break;
							}				
						}
					}
			}
			
			voxel_position = vec3(voxel_position_x,voxel_position_y,voxel_position_z); 
	
			float val = sample1(voxel_position/u_size);

			if (val<u_clim[0] || val> u_clim[1]) {
				tempPercentage = -1.0;
			} else {
				tempPercentage = (val - u_clim[0])/(u_clim[1] - u_clim[0]);
				if (tempPercentage < 0.0) {
					tempPercentage = 0.0;
				} else if (tempPercentage > 1.0) {
					tempPercentage = 1.0;
				}
			}

			float sizeShader;
			float addFactor;
			float basicSize = 10000.0;
			if (tempPercentage == 0.5 || relativeSizeFactor == 1.0) {
				sizeShader = basicSize;
			} else if (relativeSizeFactor < 1.0) {
				addFactor = 1.0-relativeSizeFactor;
				sizeShader = (tempPercentage < 0.5) ? basicSize + (basicSize*addFactor*(0.5*tempPercentage)*2.0) : basicSize - (basicSize*addFactor*(0.5*tempPercentage)*2.0) ;
			} else if (relativeSizeFactor > 1.0) {
				addFactor = relativeSizeFactor - 1.0;
				sizeShader = (tempPercentage < 0.5) ? basicSize - (basicSize*addFactor*(0.5*tempPercentage)*2.0) : basicSize + (basicSize*addFactor*(0.5*tempPercentage)*2.0) ;
			}

			vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
			if(custompercentage > temp_factor_min && custompercentage < temp_factor_max && x_position > x_factor_min && x_position < x_factor_max && y_position > y_factor_min && y_position < y_factor_max && z_position > z_factor_min && z_position < z_factor_max && h_position > h_factor_min && h_position < h_factor_max){
				if(abs(sin(u_time + 3.14159265359*y_position)) > 0.9){
					if(abs(sin(u_time + 3.14159265359*y_position)) > 0.95){
						gl_PointSize = regularSize*sizeShader * ( 1.0 / -mvPosition.z );
					} else {
						gl_PointSize = ((abs(sin(u_time + 3.14159265359*y_position)) - 0.9)/(0.95 - 0.9))*abs(sin(u_time + 3.14159265359*y_position))*regularSize*sizeShader * ( 1.0 / -mvPosition.z );
					}
				} else {
					gl_PointSize = 0.0;
				}
			} else {
				gl_PointSize = 0.0;
			}
			
			transparency = customtransparency;
			gl_Position = projectionMatrix * mvPosition;
		}
	</script>
	
	<script type="x-shader/x-vertex" id="vertexshader_2D_plane">
		varying vec3 v_position;
		attribute float voxel_level;
		
		varying float voxel_point_level;
		
		void main() {
		
			voxel_point_level = voxel_level;
		
			vec4 position4 = modelMatrix * vec4(position, 1.);
			v_position = position4.xyz;
			gl_Position = projectionMatrix * viewMatrix * position4;
		}
	</script>
	
	<script type="x-shader/x-fragment" id="fragmentshader_2D_plane">
		precision highp float;
		precision mediump sampler3D;

		varying vec3 v_position;
		uniform vec3 u_size;
		uniform vec2 u_clim;
		uniform sampler3D u_data;
		uniform sampler2D zs_data;
		uniform sampler2D u_cmdata;
		uniform sampler2D pointTexture;
		
		varying float voxel_point_level;
		
		uniform float x_min;
		uniform float x_max;
		uniform float y_min;
		uniform float y_max;
		uniform float mesolimit[38];
		uniform float cst_X;
		uniform float cst_Y;
		uniform float cst_Z;
		uniform float zs;
		uniform float transparency_factor;
		

		float sample1(vec3 texcoords) {
				/* Sample float value from a 3D texture. Assumes intensity data. */
				return texture(u_data, texcoords.xyz).r;
		}

		void main() {
		
				float voxel_position_x = (v_position[0] - x_min)/(x_max - x_min)*u_size[0];
				float voxel_position_y = -(v_position[2] - y_min)/(y_max - y_min)*u_size[2];
				float voxel_position_z = 0.0;
				vec2 voxel_xy = vec2(voxel_position_x,voxel_position_y);
				float new_zs = texture(zs_data, (voxel_xy/vec2(u_size[0],u_size[2])).xy).r;
				if(voxel_point_level < 7.0){
					if((new_zs+ mesolimit[0])*cst_Z > v_position[1]){
						voxel_position_z = 0.0;
					} else {
						for(int i=1; i< 7; i++){
							if((new_zs + mesolimit[i])*cst_Z > v_position[1]){
								float z_min = new_zs + mesolimit[i-1];
								float z_max = new_zs + mesolimit[i];
								voxel_position_z = (v_position[1] - z_min*cst_Z)/(z_max*cst_Z - z_min*cst_Z) + float(i) - 1.0;
								break;
							}				
						}
					}
				} else {
					if((new_zs+ mesolimit[7])*cst_Z > v_position[1]){
							voxel_position_z = 6.0;
						} else {
							for(int i=8; i< 38; i++){
								if((new_zs + mesolimit[i])*cst_Z > v_position[1]){
									float z_min = new_zs + mesolimit[i-1];
									float z_max = new_zs + mesolimit[i];
									voxel_position_z = (v_position[1] - z_min*cst_Z)/(z_max*cst_Z - z_min*cst_Z) + float(i) - 1.0;
									break;
								}				
							}
						}
				}
				
				vec3 voxel_position = vec3(voxel_position_x,voxel_position_y,voxel_position_z); 
		        
				//float val = sample1(voxel_position/u_size);
				//
				//if(val<u_clim[0]){
				//	gl_FragColor = vec4(0.0,0.0,0.0,0.0);
				//} else if(val>u_clim[1]){
				//	gl_FragColor = vec4(0.0,0.0,0.0,0.0);
				//} else{
				//	float new_val = (val - u_clim[0])/(u_clim[1] - u_clim[0]);
				//	gl_FragColor = texture2D(u_cmdata, vec2(new_val, 0.5));
				//	//gl_FragColor = texture2D(u_cmdata, vec2(val, 0.5));
				//}
				
				float val = fract(float(int(voxel_position[2]))/(u_size[2]/7.0));
				gl_FragColor = texture2D(u_cmdata, vec2(val, 0.5));
				
				gl_FragColor= vec4(gl_FragColor[0],gl_FragColor[1],gl_FragColor[2],transparency_factor);
				
				
		}
	</script>
	
		
	<script type="x-shader/x-vertex" id="vertexshader_3D_plane">
		varying vec3 v_position;
		
		void main() {
			vec4 position4 = modelMatrix * vec4(position, 1.);
			v_position = position4.xyz;
			gl_Position = projectionMatrix * viewMatrix * position4;
		}
	</script>
	
	<script type="x-shader/x-fragment" id="fragmentshader_3D_plane">
		precision highp float;
		precision mediump sampler3D;

		varying vec3 v_position;
		uniform vec2 u_clim;
		uniform vec3 u_size;
		uniform sampler3D u_data;
		uniform sampler2D zs_data;
		uniform sampler2D u_cmdata;
				
		uniform float x_min;
		uniform float x_max;
		uniform float y_min;
		uniform float y_max;
		//uniform float sbl_limit[7];
		//uniform float meso_limit[32];
		uniform float meso_limit[38];
		uniform float type_model;
		uniform float cst_X;
		uniform float cst_Y;
		uniform float cst_Z;
		uniform float zs;
		
		uniform bool sbl_meso_level[37];

		float sample1(vec3 texcoords) {
				/* Sample float value from a 3D texture. Assumes intensity data. */
				return texture(u_data, texcoords.xyz).r;
		}

		void main() {
		
				float voxel_position_x = (v_position[0] - x_min)/(x_max - x_min)*u_size[0];
				float voxel_position_y = -(v_position[2] - y_min)/(y_max - y_min)*u_size[2];
				float voxel_position_z = 0.0;
				vec2 voxel_xy = vec2(voxel_position_x,voxel_position_y);
				float new_zs = texture(zs_data, (voxel_xy/vec2(u_size[0],u_size[2])).xy).r;
				
				if(type_model < 0.5 ){
					if((new_zs+ meso_limit[0])*cst_Z > v_position[1]){
						discard;
					} else {
						for(int i=1; i< 7; i++){
							if((new_zs + meso_limit[i])*cst_Z > v_position[1]){
								float z_min = new_zs + meso_limit[i-1];
								float z_max = new_zs + meso_limit[i];
								voxel_position_z = (v_position[1] - z_min*cst_Z)/(z_max*cst_Z - z_min*cst_Z) + float(i) - 1.0;
								break;
							}				
						}
					}
				} else {
					if((new_zs+ meso_limit[7])*cst_Z > v_position[1]){
						if((new_zs)*cst_Z > v_position[1]){
							discard;
						}
						else {
							voxel_position_z = 6.0;
						}
					} else {
						for(int i=8; i< 38; i++){
							if((new_zs + meso_limit[i])*cst_Z > v_position[1]){
								float z_min = new_zs + meso_limit[i-1];
								float z_max = new_zs + meso_limit[i];
								voxel_position_z = (v_position[1] - z_min*cst_Z)/(z_max*cst_Z - z_min*cst_Z) + float(i) - 1.0;
								break;
							}				
						}
					}
				}
				
				vec3 voxel_position = vec3(voxel_position_x,voxel_position_y,voxel_position_z); 
						
				//float val = sample1(voxel_position/u_size);
				
				float val = fract(float(int(voxel_position_z))/(u_size[2]/7.0));
				
				if(sbl_meso_level[int(voxel_position_z)] == false){
					discard;
				} else {
				
				gl_FragColor = texture2D(u_cmdata, vec2(val, 0.5));
				
				//int intpart = (int)voxel_position_z;
				//double decpart = voxel_position_z - intpart;
				//
				//gl_FragColor = vec4(decpart,0.0,0.0,1.0);
	
				//	if(val<u_clim[0]){
				//		discard;
				//	} else if(val>u_clim[1]){
				//		discard;
				//	} else{
				//		float new_val = (val - u_clim[0])/(u_clim[1] - u_clim[0]);
				//		gl_FragColor = texture2D(u_cmdata, vec2(new_val, 0.5));
				//	}
				}
				
					
				
				
		}
	</script>
	<script type="module">
		
		import { init} from './js/initialisation.js'
		import { render } from './js/creative_functions.js'
		import { initialise } from './js/menu.js'
		import {} from './js/filter-sliders.js'

		init();
		render();
		initialise();
	
	</script>
	
	
	
	
</body>
</html>